import sqlite3
import hashlib
import secrets
from datetime import datetime, timedelta
import os

class UserAuthDB:
    def __init__(self, db_path="user_auth.db"):
        """Initialize the database connection and create tables if they don't exist"""
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Create the database tables"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create users table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username VARCHAR(50) UNIQUE NOT NULL,
                email VARCHAR(100) UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                salt TEXT NOT NULL,
                role VARCHAR(20) DEFAULT 'user',
                is_active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_login TIMESTAMP,
                failed_login_attempts INTEGER DEFAULT 0,
                locked_until TIMESTAMP
            )
        ''')
        
        # Create sessions table for managing login sessions
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                session_token TEXT UNIQUE NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                expires_at TIMESTAMP NOT NULL,
                is_active BOOLEAN DEFAULT 1,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        ''')
        
        # Create audit log table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                action VARCHAR(100) NOT NULL,
                details TEXT,
                ip_address VARCHAR(45),
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def hash_password(self, password):
        """Generate a secure password hash with salt"""
        salt = secrets.token_hex(32)
        password_hash = hashlib.pbkdf2_hmac('sha256', 
                                          password.encode('utf-8'), 
                                          salt.encode('utf-8'), 
                                          100000)
        return password_hash.hex(), salt
    
    def verify_password(self, password, stored_hash, salt):
        """Verify a password against its hash"""
        password_hash = hashlib.pbkdf2_hmac('sha256',
                                          password.encode('utf-8'),
                                          salt.encode('utf-8'),
                                          100000)
        return password_hash.hex() == stored_hash
    
    def create_user(self, username, email, password, role='user'):
        """Create a new user account"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            # Check if username or email already exists
            cursor.execute("SELECT id FROM users WHERE username = ? OR email = ?", 
                         (username, email))
            if cursor.fetchone():
                return False, "Username or email already exists"
            
            # Hash the password
            password_hash, salt = self.hash_password(password)
            
            # Insert new user
            cursor.execute('''
                INSERT INTO users (username, email, password_hash, salt, role)
                VALUES (?, ?, ?, ?, ?)
            ''', (username, email, password_hash, salt, role))
            
            user_id = cursor.lastrowid
            
            # Log the action
            self.log_action(cursor, user_id, "USER_CREATED", f"User {username} created")
            
            conn.commit()
            return True, f"User {username} created successfully"
            
        except sqlite3.Error as e:
            conn.rollback()
            return False, f"Database error: {str(e)}"
        finally:
            conn.close()
    
    def authenticate_user(self, username, password, ip_address=None):
        """Authenticate a user login attempt"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            # Get user details
            cursor.execute('''
                SELECT id, username, password_hash, salt, role, is_active, 
                       failed_login_attempts, locked_until
                FROM users WHERE username = ? OR email = ?
            ''', (username, username))
            
            user = cursor.fetchone()
            
            if not user:
                self.log_action(cursor, None, "LOGIN_FAILED", 
                              f"Login attempt with invalid username: {username}", ip_address)
                conn.commit()
                return False, "Invalid credentials"
            
            user_id, username, stored_hash, salt, role, is_active, failed_attempts, locked_until = user
            
            # Check if account is locked
            if locked_until:
                lock_time = datetime.fromisoformat(locked_until)
                if datetime.now() < lock_time:
                    return False, f"Account locked until {locked_until}"
                else:
                    # Clear the lock
                    cursor.execute("UPDATE users SET locked_until = NULL WHERE id = ?", (user_id,))
            
            # Check if account is active
            if not is_active:
                return False, "Account is deactivated"
            
            # Verify password
            if self.verify_password(password, stored_hash, salt):
                # Successful login - reset failed attempts and update last login
                cursor.execute('''
                    UPDATE users 
                    SET failed_login_attempts = 0, last_login = CURRENT_TIMESTAMP, locked_until = NULL
                    WHERE id = ?
                ''', (user_id,))
                
                # Create session token
                session_token = secrets.token_urlsafe(32)
                expires_at = datetime.now() + timedelta(hours=24)  # 24 hour session
                
                cursor.execute('''
                    INSERT INTO sessions (user_id, session_token, expires_at)
                    VALUES (?, ?, ?)
                ''', (user_id, session_token, expires_at))
                
                self.log_action(cursor, user_id, "LOGIN_SUCCESS", "User logged in", ip_address)
                conn.commit()
                
                return True, {
                    "user_id": user_id,
                    "username": username,
                    "role": role,
                    "session_token": session_token,
                    "expires_at": expires_at.isoformat()
                }
            else:
                # Failed login - increment counter
                failed_attempts += 1
                locked_until = None
                
                # Lock account after 5 failed attempts
                if failed_attempts >= 5:
                    locked_until = datetime.now() + timedelta(minutes=30)
                
                cursor.execute('''
                    UPDATE users 
                    SET failed_login_attempts = ?, locked_until = ?
                    WHERE id = ?
                ''', (failed_attempts, locked_until, user_id))
                
                self.log_action(cursor, user_id, "LOGIN_FAILED", 
                              f"Failed login attempt ({failed_attempts}/5)", ip_address)
                conn.commit()
                
                if locked_until:
                    return False, "Too many failed attempts. Account locked for 30 minutes."
                else:
                    return False, f"Invalid credentials ({failed_attempts}/5 attempts)"
                    
        except sqlite3.Error as e:
            return False, f"Database error: {str(e)}"
        finally:
            conn.close()
    
    def validate_session(self, session_token):
        """Validate a session token"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT s.user_id, u.username, u.role, s.expires_at
                FROM sessions s
                JOIN users u ON s.user_id = u.id
                WHERE s.session_token = ? AND s.is_active = 1 AND u.is_active = 1
            ''', (session_token,))
            
            session = cursor.fetchone()
            
            if not session:
                return False, "Invalid session"
            
            user_id, username, role, expires_at = session
            
            # Check if session has expired
            if datetime.now() > datetime.fromisoformat(expires_at):
                # Deactivate expired session
                cursor.execute("UPDATE sessions SET is_active = 0 WHERE session_token = ?", 
                             (session_token,))
                conn.commit()
                return False, "Session expired"
            
            return True, {
                "user_id": user_id,
                "username": username,
                "role": role
            }
            
        except sqlite3.Error as e:
            return False, f"Database error: {str(e)}"
        finally:
            conn.close()
    
    def logout_user(self, session_token):
        """Logout a user by deactivating their session"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute("UPDATE sessions SET is_active = 0 WHERE session_token = ?", 
                         (session_token,))
            if cursor.rowcount > 0:
                conn.commit()
                return True, "Logged out successfully"
            else:
                return False, "Invalid session token"
        except sqlite3.Error as e:
            return False, f"Database error: {str(e)}"
        finally:
            conn.close()
    
    def log_action(self, cursor, user_id, action, details=None, ip_address=None):
        """Log an action to the audit log"""
        cursor.execute('''
            INSERT INTO audit_log (user_id, action, details, ip_address)
            VALUES (?, ?, ?, ?)
        ''', (user_id, action, details, ip_address))
    
    def get_user_info(self, user_id):
        """Get user information by ID"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT id, username, email, role, is_active, created_at, last_login
                FROM users WHERE id = ?
            ''', (user_id,))
            
            user = cursor.fetchone()
            if user:
                return True, {
                    "id": user[0],
                    "username": user[1],
                    "email": user[2],
                    "role": user[3],
                    "is_active": bool(user[4]),
                    "created_at": user[5],
                    "last_login": user[6]
                }
            else:
                return False, "User not found"
                
        except sqlite3.Error as e:
            return False, f"Database error: {str(e)}"
        finally:
            conn.close()
    
    def create_admin(self, username, email, password):
        """Create an admin user"""
        return self.create_user(username, email, password, role='admin')
    
    def is_admin(self, user_id):
        """Check if user is an admin"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute("SELECT role FROM users WHERE id = ?", (user_id,))
            result = cursor.fetchone()
            return result and result[0] == 'admin'
        except sqlite3.Error:
            return False
        finally:
            conn.close()